package me.bait.exploitsx.exploits;

import com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent;
import me.bait.exploitsx.ExploitsX;
import me.bait.exploitsx.util.API;
import me.bait.exploitsx.util.ConfigHelper;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityPortalEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.scheduler.BukkitRunnable;

// -- // WARNING \\ -- 
// -- THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
// -- THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
// -- 
// -- DECOMPILING, COPYING OR REDISTRIBUTING THIS CODE IS A CRIME. IF YOU HAVE ANY QUESTIONS OR CONCERNS
// -- THEY MUST BE VOICED DIRECTLY TO BAITCORP EXECUTIVES BEFORE PERSONAL ACTION.
// -- 
// -- ExploitsX Sebastian Giheta 2019-2020
// -- //         \\ -- 

public class OnTeleport implements Listener {

	private static boolean gateway = ConfigHelper.getBoolean("gateway", true);
	private static boolean portal = ConfigHelper.getBoolean("portal", true);
	private static boolean riding = ConfigHelper.getBoolean("disable-riding-teleport", true);
	private static boolean debug = ConfigHelper.getBoolean("debug", true);
	private static boolean tlexploit = ConfigHelper.getBoolean("teleport-exploit-patch", true);

	public static void reload() {
		gateway = ConfigHelper.getBoolean("gateway", true);
		portal = ConfigHelper.getBoolean("portal", true);
		riding = ConfigHelper.getBoolean("disable-riding-teleport", true);
		debug = ConfigHelper.getBoolean("debug", true);
		tlexploit = ConfigHelper.getBoolean("teleport-exploit-patch", true);
	}

	@EventHandler
	public void onEntityEndPortal(EntityTeleportEndGatewayEvent event) {
		if (gateway && !(event.getEntity() instanceof Player)) {
			event.setCancelled(true);
		}
	}

	@EventHandler
	public void onEntityPortal(EntityPortalEvent event) {
		if (portal && !(event.getEntity() instanceof Player)) {
			event.setCancelled(true);
		}
	}

	@EventHandler
	public void onPTeleport(PlayerTeleportEvent e) {
		Player player = e.getPlayer();
		if (player.isInsideVehicle() && riding) {
			e.setCancelled(true);
			if (debug) {
				Bukkit.getLogger().info("ExploitsX cancelled a riding teleport from " + e.getPlayer());
			}
		}
		int spawn = ExploitsX.getPlugin().getConfig().getInt("sr");
		Location pl = e.getPlayer().getLocation();
		if (spawn != 0 && spawn != -1 && !player.isOp() && pl.getBlockX() < spawn && pl.getBlockX() > -spawn
				&& pl.getBlockZ() < spawn && pl.getBlockZ() > -spawn
				&& (e.getCause() == PlayerTeleportEvent.TeleportCause.PLUGIN
						|| e.getCause() == PlayerTeleportEvent.TeleportCause.COMMAND)) {
			player.sendMessage(ChatColor.translateAlternateColorCodes('&',
					"&6you must be " + spawn + " from spawn to use /home && /tpa"));
			e.setCancelled(true);
		}
		if (tlexploit) {
			if (debug) {
				Bukkit.getLogger()
						.info("ExploitsX Detected teleport from " + e.getPlayer() + " executed by " + e.getCause());
			}
			if (e.getCause() == PlayerTeleportEvent.TeleportCause.COMMAND) {
				e.setCancelled(true);
				Location to = e.getTo();
				API.teleportPlayer(player, API.getRandom(7500), 18000, API.getRandom(7500), player.getWorld());
				new BukkitRunnable() {
					@Override
					public void run() {
						if (debug) {
							Bukkit.getLogger().info("ExploitsX Fixing Teleport location for " + e.getPlayer());
						}
						API.teleportPlayer(player, to.getBlockX(), to.getBlockY(), to.getBlockZ(), to.getWorld());
					}
				}.runTaskLater(ExploitsX.getPlugin(), 2);
			}
		}
	}
}
