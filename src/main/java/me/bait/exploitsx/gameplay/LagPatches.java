package me.bait.exploitsx.gameplay;

import me.bait.exploitsx.ExploitsX;
import me.bait.exploitsx.util.API;
import me.bait.exploitsx.util.ConfigHelper;
import me.bait.exploitsx.util.TPS;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.entity.Wither;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.NotePlayEvent;
import org.bukkit.event.entity.EntitySpawnEvent;
import org.bukkit.event.entity.ExplosionPrimeEvent;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.scheduler.BukkitRunnable;

import java.util.HashMap;

//-- // WARNING \\ --
// Licence publique Creative Commons Attribution - Utilisation non commerciale - Pas d’Œuvre dérivée 4.0 International
//        Lorsque Vous exercez les Droits accordés par la licence (définis ci-dessous), Vous acceptez d'être lié par les termes et conditions de la présente Licence publique Creative Commons Attribution - Utilisation non commerciale - Pas d’Œuvre dérivée 4.0 International (la « Licence publique »). Dans la mesure où la présente Licence publique peut être interprétée comme un contrat, Vous bénéficiez des Droits accordés par la licence en contrepartie de Votre acceptation des présents termes et conditions, et le Donneur de licence Vous accorde ces droits en contrepartie des avantages que lui procure le fait de mettre à disposition l’Œuvre sous licence en vertu des présents termes et conditions.
//-- https://creativecommons.org/licenses/by-nc-nd/4.0/deed.fr
//-- ExploitsX Sebastian Giheta 2019-2020
//-- //         \\ --

public class LagPatches implements Listener {

	private static final HashMap<Player, Integer> vl = new HashMap<>();
	private static double vdouble = ConfigHelper.getDouble("elytraint");
	private static double noteremove = ConfigHelper.getDouble("note-remove");
	private static double notecancel = ConfigHelper.getDouble("note-tps");
	private static double tntint = ConfigHelper.getDouble("tntint");
	private static double witherspawn = ConfigHelper.getDouble("witherspawn");
	private static int maxwithers = ConfigHelper.getInt("maxwithers");

	public static void clear() {
		vl.clear();
	}

	public static void reload() {
		vdouble = ConfigHelper.getDouble("elytraint");
		noteremove = ConfigHelper.getDouble("note-remove");
		notecancel = ConfigHelper.getDouble("note-tps");
		tntint = ConfigHelper.getDouble("tntint");
		witherspawn = ConfigHelper.getDouble("witherspawn");
		maxwithers = ConfigHelper.getInt("maxwithers");
	}

	public void tell(Player p) {
		if (vl.containsKey(p)) {
			if (vl.get(p) == 0) {
				vl.put(p, 1);
				p.sendMessage(ChatColor.DARK_RED
						+ "Elytras are disabled in low tps. Move to y level 5,000 or more once the TPS is back up in order to fly disregarding the TPS.");
				Bukkit.getScheduler().scheduleSyncDelayedTask(ExploitsX.getPlugin(),
						new BukkitRunnable() {
							@Override
							public void run() {
								vl.put(p, 0);
							}
						}, 60L);
			}
		} else {
			vl.put(p, 0);
		}
	}

	@SuppressWarnings("deprecation")
	@EventHandler(priority = EventPriority.HIGHEST)
	public void inElytra(final PlayerMoveEvent e) {
		Player p = e.getPlayer();
		if (p.isGliding()) {
			if (TPS.getTPS() <= vdouble) {
				Location l2 = e.getTo();
				if (l2.getY() < 5000) {
					Location l = e.getFrom();
					if (Math.abs(l.getZ() - l2.getZ())
							+ Math.abs(l.getX() - l2.getX())
							+ Math.abs(l.getY() - l2.getY()) > vdouble) {
						e.setCancelled(true);
						tell(p);
					}
				}
			}
		}
	}

	@EventHandler
	public void onNote(NotePlayEvent event) {
		if (API.getTps() < notecancel) {
			event.setCancelled(true);
			Material t = event.getBlock().getType();
			if (API.getTps() < noteremove
					&& t != Material.BEDROCK
					&& t != Material.ENDER_PORTAL_FRAME) {
				event.getBlock().setType(Material.AIR);
			}
		}
	}

	@EventHandler
	public void onTnt(ExplosionPrimeEvent event) {
		if (TPS.getTPS() <= tntint) {
			event.setCancelled(true);
		}
	}

	@EventHandler
	public void onWitherSpawn(EntitySpawnEvent event) {
		if (event.getEntity() instanceof Wither) {
			if (TPS.getTPS() <= witherspawn) {
				event.setCancelled(true);
			}
			int count = 0;
			for (Entity e : event.getEntity().getWorld().getNearbyEntities(event.getLocation(), 64, 64, 64)) {
				if (e.getType() == EntityType.WITHER) {
					count = count + 1;
				}
			}
			if (count > maxwithers) {
				event.setCancelled(true);
				Location l = event.getLocation();
				Entity el = event.getEntity();
				API.alertMessage("Cancelled a wither spawn from "
						+ (el.getWorld().getNearbyPlayers(el.getLocation(),
						20.0D))
						+ " due to high amounts at " + l.getX() + ", "
						+ l.getY() + ", " + l.getZ());
			}
		}
	}
}
