package me.bait.exploitfixer.exploits;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerQuitEvent;
import org.bukkit.event.player.PlayerShearEntityEvent;
import org.bukkit.scheduler.BukkitRunnable;

import me.bait.exploitfixer.exploitfixer;
import me.bait.exploitfixer.util.API;
import me.bait.exploitfixer.util.CH;
import me.bait.exploitfixer.util.ViolationUtils;

// // WARNING \\
// THIS WORK IS UNDER EXCLUSIVE COPRIGHT FOR BAITCORP LABS. DISTRIBUTION, MODIFICATION, SELLING, OR SHARING WITHOUT EXPLICIT PERMISSION FROM BAITCORP LABS IS STRICTLY PROHIBITED.
// THIS PROGRAM IS LICENSED FOR MODIFICATION TO AND ONLY TO: "BAITCORP LABS" [FR], "CCHOST PARIS" [FR].
// 
// DECOMPILING, COPYING OR REDISTRIBUTING THIS CODE IS A CRIME. IF YOU HAVE ANY QUESTIONS OR CONCERNS
// THEY MUST BE VOICED DIRECTLY TO BAITCORP EXECUTIVES BEFORE PERSONAL ACTION.
// 
// ExploitsX Sebastian Giheta 2019-2020
// //         \\

public class Interaction implements Listener {

	static ViolationUtils interactMan = new ViolationUtils();
	static int intcancel = CH.getInt("interact-cancel");
	static int intkick = CH.getInt("interact-kick");
	static boolean eint = CH.getBoolean("interact-limit", false);

	public static void begin() {
		interactMan.begin(4);
		reload();
	}

	public static void reload() {
		intcancel = CH.getInt("interact-cancel");
		intkick = CH.getInt("interact-kick");
		eint = CH.getBoolean("interact-limit", false);
	}

	@EventHandler
	public void onInteract(PlayerInteractEntityEvent event) {
		if (!eint)
			return;
		if (interactMan.getVls(event.getPlayer()) >= intkick) {
			event.setCancelled(true);
		}
		pe(event.getPlayer());
	}

	@EventHandler
	public void onInteract(PlayerInteractEvent event) {
		if (!eint)
			return;
		if (interactMan.getVls(event.getPlayer()) >= intcancel) {
			if (event.getAction() == Action.RIGHT_CLICK_BLOCK
					&& API.isTile(event.getClickedBlock().getType().toString())) {
				event.setCancelled(true);
				pe(event.getPlayer());
			}
		} else {
			if ((int) Math.round(Math.random()) == 1)
				pe(event.getPlayer());
		}
	}

	@EventHandler
	public void onLeave(PlayerQuitEvent event) {
		if (!eint)
			return;
		interactMan.resetVls(event.getPlayer());
	}

	@EventHandler
	public void onShear(PlayerShearEntityEvent event) {
		if (!eint)
			return;
		if (interactMan.getVls(event.getPlayer()) >= intkick) {
			event.setCancelled(true);
		}
		pe(event.getPlayer());
	}

	public void pe(Player player) {
		if (!eint)
			return;
		interactMan.addVls(player, 1);
		interactMan.removeVL(player);
		new BukkitRunnable() {
			@Override
			public void run() {
				if (player.isOnline()) {
					if (interactMan.vlMapContainsPlayer(player)) {
						if (interactMan.getVls(player) > 1) {
							interactMan.removeVL(player);
						}
						if (interactMan.getVls(player) < 2) {
							interactMan.resetVls(player);
						}
					}
				} else {
					interactMan.resetVls(player);
				}
			}
		}.runTaskLater(exploitfixer.getPlugin(), 100L);
		if (interactMan.getVls(player) >= intkick) {
			API.kickPlayer(player, API.getPrefix() + " > &6You are interacting too fast, sorry ): ("
					+ interactMan.getVls(player) + "vls)");
			API.alertMessage(API.getPrefix() + "&c " + player.getName() + "> &r&6Has been kicked for fastinteract ("
					+ interactMan.getVls(player) + "vls)");
			interactMan.resetVls(player);
		}
	}
}
